# 产品需求

🖥️ 用户交互与界面设计

1.  REPL会话管理
    ◦   启动与初始化：程序启动后，应首先检查本地是否存在现有的Keystore文件。如果存在，则提示用户输入密码解锁钱包；如果不存在，则引导用户创建新钱包或通过助记词导入现有钱包。成功解锁或创建后，进入 wallet > 提示符状态。

    ◦   命令集与帮助系统：除了已列出的命令，还需实现 help [command] 命令，用于列出所有命令或显示特定命令的详细用法。例如，help send 应展示命令格式、参数说明和使用示例。

    ◦   历史与补全：为实现良好的用户体验，REPL 应支持命令行历史记录（通过上下箭头键切换）和命令/地址的 Tab 键补全功能。

2.  交互反馈与状态提示
    ◦   分级提示信息：所有操作反馈应明确且符合场景。例如，balance 命令成功后，应清晰显示资产类型、余额数量及更新时间；进行中操作（如交易广播）应显示“等待网络确认...”等动态提示；失败时需明确错误原因（如“密码错误”、“网络连接超时”、“余额不足”）。

    ◦   确认机制：对于 send 等关键操作，在执行前必须进行二次确认。提示信息应包含收款地址（可做部分掩码处理，如0x1234...5678）、金额、预估手续费，并等待用户输入 y/yes 确认后才继续执行。
3. 支持国际化
    程序语言要支持中文、英语和日语等

🔐 钱包与密钥管理细则

1.  密钥安全生命周期管理
    ◦   密钥生成与存储：严格遵循 BIP39 标准生成助记词，并基于 BIP32/44 标准生成层级确定性钱包（HD Wallet）结构。私钥必须使用 AES-256-GCM 等强加密算法在本地加密存储为 Keystore 文件（格式可参考以太坊的 Web3 密钥库标准）。加密过程应加入随机盐和高强度的密钥派生函数（如 scrypt 或 PBKDF2）以增强抗暴力破解能力。

    ◦   内存安全：私钥在内存中应以加密形态或仅在需要签名的极短时间内以明文形态存在，并在使用后立即通过安全的内存清理方式（例如，使用完后将内存区域覆写为零）进行清除，防止内存泄露风险。

    ◦   会话安全：lock 命令执行后，应立即清除内存中的私钥、密码等所有敏感信息，并将会话状态重置为未解锁状态。exit 命令在执行 lock 操作的基础上，安全关闭所有网络连接和文件句柄后退出程序。

2.  备份与恢复流程
    ◦   备份引导：创建钱包时，必须强制用户在新钱包可操作前，完整、准确地备份由程序生成的助记词。界面应给出明确的安全警告，提示用户助记词是恢复钱包的唯一凭证。

    ◦   恢复验证：通过助记词恢复钱包时，应提供验证机制（如让用户随机输入助记词中的几个词），以确保用户正确备份，从而避免因备份错误导致资产永久丢失。

💰 核心资产操作逻辑

1.  余额查询
    ◦   查询功能需支持连接到用户配置的区块链节点（RPC）实时获取余额。显示信息应包括代币种类和数量，并可考虑显示其等值法币价值（需集成外部汇率 API）。

    ◦   架构设计上，余额查询模块应与具体的链类型解耦，为未来支持多链做好预留。

2.  交易发起与广播
    ◦   交易构建：send 命令需解析目标地址的合法性，并自动获取当前网络建议的 Gas 价格（如通过公共 Gas 价格预言机或默认节点的 eth_gasPrice 接口）。应允许用户通过 --gas-price 等参数手动覆盖建议值。

    ◦   签名与广播：交易在得到用户确认并使用内存中的私钥签名后，通过连接的节点进行广播。程序需监控交易状态，并提供交易哈希（Tx Hash）以供用户查询。

⚙️ 配置、扩展性与非功能性需求

1.  配置文件规范
    ◦   默认配置文件（如 config.toml）应在首次运行或检测到缺失时自动生成。其内容需包括：默认区块链节点的 RPC 地址、端口、超时设置，以及日志级别、数据存储路径等。

2.  面向扩展的架构设计
    ◦   应采用清晰的分层架构，例如 internal/core（核心钱包逻辑，如密钥管理、交易构建）、cmd/cli（命令行交互与解析）、pkg/crypto（加密算法实现）、pkg/chain（区块链适配器层）。在 pkg/chain 内定义如 ChainProvider 接口，然后为不同的链类型（如 EVM、UTXO）实现该接口，从而实现平滑扩展 。

3.  安全性加固
    ◦   操作审计：所有敏感操作（如创建钱包、发送交易、解锁失败）都应有详细的、不可篡改的本地日志记录（日志中绝不含私钥、助记词或明文密码）。

    ◦   异常处理：程序必须妥善处理各种异常情况，如用户输入中断（Ctrl+C）、网络中断、节点无响应等。确保在任何异常退出时，都能安全地清理内存中的敏感信息。

# 核心技术选型
|技术领域|推荐方案|说明|
|--|--|--|
|开发语言|Go|​语法简洁，性能优异，天生适合高并发网络操作（如与区块链节点通信），且拥有强大的标准库和丰富的加密库生态。|
|REPL交互框架​|纯Go实现（如promptui）或chzyer/readline​|避免依赖C库（如GNU readline）以简化部署。这些库能提供历史命令、Tab补全等核心功能，同时保持对Windows、macOS和Linux的良好支持。|
|命令行解析​|spf13/cobra​|业界标准，功能强大，能很好地支持子命令、标志（flag）解析，并能与spf13/viper（配置管理库）无缝集成，自动生成帮助文档。|
|加密与密钥管理​|Go标准库crypto+ethereum/go-ethereum/crypto​|直接使用或参考其经过严格审计的、对BIP39（助记词）、BIP32/44（HD钱包）和Keystore（加密私钥文件）的成熟实现，确保密钥安全。|
|配置管理​|spf13/viper​|​支持多种格式（TOML, YAML, JSON等），可方便地与Cobra集成，管理通过RPC读取的配置文件。|
|国际化(i18n)​|nicksnyder/go-i18n/v2​|专为Go设计的国际化库，支持标准的JSON格式语言包，能够轻松实现运行时语言动态切换|
|显示模板|go标准库|显示与逻辑分离，方便不影响业务逻辑的前提下，更换显示样式。|

🏗️ 系统架构与模块设计

采用清晰的分层架构，将核心逻辑与交互界面解耦，便于测试、维护和未来扩展。

## 目录结构

```bash
slowmade/
├── main.go                     // 主程序入口
├── cmd/
│   └── root.go                 // 程序根命令，，负责初始化、依赖注入
├── internal/
│   ├── core/                   // 核心业务逻辑层
│   │   ├── wallet.go           // 钱包生命周期管理（创建、解锁、锁定）
│   │   ├── keystore.go         // Keystore文件的安全读写
│   │   └── signer.go           // 交易签名逻辑
│   ├── chain/                  // 区块链适配器层
│   │   ├── provider.go         // 定义ChainProvider接口
│   │   └── evm/                // EVM兼容链（如以太坊）实现
│   │       ├── adapter.go
│   │       └── rpc_client.go
│   └── repl/                   // 交互层
│       ├── session.go          // 会话状态管理（是否已解锁等）
│       ├── prompt.go           // REPL提示符和输入循环
│       └── completer.go        // 命令补全逻辑
├── pkg/
│   ├── crypto/                 // 基础加密包（可封装或直接引用外部库）
│   └── i18n/                  // 国际化包
│       ├── bundle.go
│       └── locales/           // 语言包文件
│           ├── active.en.toml
│           ├── active.zh.toml
│           └── active.ja.toml
├── config.toml                // 默认配置文件
└── templates/                 // 自定义文本模板
```
## 核心模块详解

### REPL会话与交互模块 (internal/repl)：此模块是应用的“大脑”，负责协调所有用户交互。

1. 会话管理 (session.go)：维护一个核心的Session结构体，包含当前钱包实例、区块链提供商、语言设置等全局状态。执行lock和exit命令时，必须确保安全地清理内存中的敏感信息。

2. 提示与补全 (prompt.go, completer.go)：利用选定的REPL库，实现命令历史记录和基于上下文的Tab补全功能（例如，输入send后能补全已知地址）。这能极大提升用户体验。
### 钱包与密钥管理核心 (internal/core)：这是应用的“保险库”，安全性是最高准则。
1. 密钥安全生命周期：私钥的生成、加密存储和解密操作都应在此模块内。必须遵循：使用强随机数生成助记词；使用高强度算法（如scrypt）从密码派生加密密钥；私钥在使用后立即从内存中安全擦除。

2. Keystore管理 (keystore.go)：实现与以太坊Keystore格式兼容的加密存档读写功能，确保跨钱包应用的兼容性。
### 区块链适配器层 (internal/chain)：此模块是应用的“手脚”，负责与外部区块链网络通信。
1. 设计模式：定义一个ChainProvider接口，包含GetBalance(address), SendTransaction(tx), EstimateGasPrice()等方法。
2. 多链扩展：通过为EVM、UTXO等不同链类型实现此接口，可以轻松扩展对多链的支持。例如，internal/chain/evm/adapter.go就是ChainProvider的一个具体实现，它封装了与EVM节点RPC的交互逻辑。
### 国际化框架 (pkg/i18n)：
1. 实现原理：使用选定的i18n库，将所有用户可见的字符串（提示信息、命令帮助等）提取到各语言对应的TOML或JSON文件中。
2. 动态切换：在REPL会话中，根据用户选择或系统设置动态加载对应的语言包，并通过函数（如i18n.Tr("MSG_BALANCE_TITLE")）获取本地化文本。

### 关键实现细节与安全考量
1. 内存安全：Go的运行时特性使得无法绝对保证内存页被即时清零。但对于敏感数据（如字节数组形式的私钥），应在使用后显式地将其覆盖（例如，通过for i := range key { key[i] = 0 }）。尽管有局限，这是一个重要的防御性编程实践。
2. 配置与日志：
* 使用Viper管理配置，支持配置文件、环境变量和命令行标志的优先级合并。
* 日志记录必须详尽，但绝对禁止记录明文私钥、助记词或原始密钥。只记录操作类型、地址、交易哈希等非敏感元数据。
3. 异常处理：使用Go的defer、panic和recover机制确保程序在遇到不可预知错误或用户中断（Ctrl+C）时，能优雅地执行清理流程，特别是安全地锁定钱包。

# 项目开发
```
slowmade/
├── main.go
├── cmd/
│   └── root.go
├── internal/
│   ├── core/
│   │   ├── wallet.go
│   │   ├── keystore.go
│   │   └── signer.go
│   ├── chain/
│   │   ├── provider.go
│   │   └── evm/
│   │       ├── adapter.go
│   │       └── rpc_client.go
│   └── repl/
│       ├── session.go
│       ├── prompt.go
│       └── completer.go
├── pkg/
│   ├── crypto/
│   │   └── hdwallet.go
│   └── i18n/
│       ├── bundle.go
│       └── locales/
│           ├── active.en.toml
│           ├── active.zh.toml
│           └── active.ja.toml
├── config.toml
├── go.mod
└── go.sum
```
